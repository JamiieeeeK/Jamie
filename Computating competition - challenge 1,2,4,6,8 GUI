import math
from matplotlib import pyplot as plt
import tkinter as tk
from tkinter import * 
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk #* canvas and toolbar
import time 
from matplotlib.animation import FuncAnimation


root = tk.Tk()
root.title("GUI -(JK)") 
root.geometry("1030x550") 

fig,ax = plt.subplots()
frame = tk.Frame(root)
canvas = FigureCanvasTkAgg(fig, master = frame)
canvas.get_tk_widget().grid()
frame.grid(row=1,rowspan=15, column=1, columnspan=1, padx=15, pady=5)
plt.grid()
canvas.draw() 
toolbar=NavigationToolbar2Tk(canvas, frame, pack_toolbar=False)
toolbar.update()
toolbar.grid(row=11, column=0, pady=2)


velocity = tk.StringVar(root,value='0') 
theta = tk.StringVar(root,value='0') 
height = tk.StringVar(root,value='0')

initial_velocity = 0.00 
launch_angle = 0.00
initial_height = 0.00

Stamp = False 
show_apogee = False 
Animation = False 


def entry_values():
    initial_velocity = float(velocity.get())
    iVelocity_slider.set(initial_velocity) 
    launch_angle = float(theta.get())%360
    angle_slider.set(launch_angle)
    initial_height = float(height.get())
    iHeight_slider.set(initial_height)

def Enter(self):
    initial_velocity = float(velocity.get())
    iVelocity_slider.set(initial_velocity)
    launch_angle = float(theta.get())%360
    angle_slider.set(launch_angle)
    initial_height = float(height.get())
    iHeight_slider.set(initial_height)

def ivSlider(self):
    global initial_velocity
    initial_velocity = float(iVelocity_slider.get())
    velocity.set(initial_velocity) 
    iVelocity_label = Label(root, text=f"   Initial velocity / ms^-1 : {initial_velocity}   ", font=12).grid(row=1,column=2)
    graph() 

def anSlider(self):
    global launch_angle
    launch_angle = float(angle_slider.get())
    theta.set(launch_angle)
    angle_label = Label(root,text=f"   Launch angle / ° : {launch_angle}   ", font=12).grid(row=3,column=2)
    graph()

def ihSlider(self):
    global initial_height
    initial_height = float(iHeight_slider.get())
    height.set(initial_height)
    iHeight_label = Label(root,text=f"   Initial height / m : {initial_height}   ", font=12).grid(row=5,column=2)
    graph()

def reset_values():
    initial_velocity = 0.00
    launch_angle = 0.00
    initial_height = 0.00
    iVelocity_slider.set(initial_velocity)
    angle_slider.set(launch_angle)
    iHeight_slider.set(initial_height)
    set_graph()



def graph():
    set_graph() 
    global AnimationX 
    global AnimationY 
    global Stamp 
    a = -9.81 
    dt = 0.01 
    t = 0 
    u = initial_velocity 
    angle = math.radians(launch_angle) 
    iHeight = initial_height 
    hDistance = 0 
    s = 0 
    vDistance = iHeight 
    step = 0 

    vVelocity = round(u*math.sin(angle),13)  
    hVelocity = round(u*math.cos(angle),13)
    x = [] 
    y = [] 
    dx = [] 
    dy = []
    Bx = []
    By = []

    AnimationX = []
    AnimationY = []

    x1 = 0
    x2 = 0
    y1 = iHeight
    y2 = iHeight
    Distance = 0
    temp = 0
    
    while vDistance > 0: 
        hDistance = hVelocity*t 
        x.append(hDistance) 

        s = vVelocity*t + 0.5*a*t**2 #* ut + 1/2at^2
        vDistance = iHeight+s 
        y.append(vDistance) 


        if round(t,1) == step: 
            dx.append(hDistance)
            dy.append(vDistance)
            step = round((step + 0.1),1)
            
        t = round((t + dt),13)
        
        x2 = x1
        x1 = hDistance
        y2 = y1
        y1 = vDistance
        temp = math.sqrt((x1-x2)**2 + (y1-y2)**2)
        Distance = Distance + temp

    
    AnimationX = dx 
    AnimationY = dy
    AnimationX.append(hDistance)
    AnimationY.append(vDistance)

    Distance = Distance - temp

    #* calculate the maximum point
    global hMaxDistance
    global vMaxHeight
    
    #* vertical distance 
    if launch_angle > 180: 
        vMaxHeight = 0
    else:
        vMaxHeight = (vVelocity**2)/(-2*a) #* final_vertical_velocity = 0, v^2 = u^2 +2as
        
    MaxTime = round(math.sqrt((-2*vMaxHeight)/a),13) #* s = vt-1/2at^2
    hMaxDistance = MaxTime*hVelocity #* horizontal distance = velocity*time
    vMaxHeight = vMaxHeight + iHeight #* vertical distance + initial height

    t = t-dt
    ax.plot(x,y, markersize=5, c='darkblue', label=f'projectile: time={round(t,1)}s distance={round(Distance,1)}m') 


    if Stamp == True:
        ax.plot(dx,dy,'.', markersize=5, c='cornflowerblue', label='time stamp')

    if show_apogee == True:
        apogee_point = ax.plot(hMaxDistance,vMaxHeight, '*', c='orange', zorder=2, label=f"apogee: {round(hMaxDistance,2)}, {round(vMaxHeight,2)}")    
    ax.legend()
    canvas.draw() 


def set_graph():
    ax.clear() 
    ax.spines['left'].set_position('zero')  
    ax.spines['bottom'].set_position('zero')
    ax.spines['right'].set_color('none') 
    ax.spines['top'].set_color('none')

    plt.xlabel(" horizontal distance/m ") 
    plt.ylabel(" vertical distance/m ")
    plt.title("Projectile Model") 
    plt.grid() 
    plt.autoscale()
    canvas.draw() 
    #apogee_label = Label(root, text="                               ", font=7).grid(row=10,column=4)


def time_stamp():
    global Stamp
    if Stamp == True: 
        Stamp = False
    else:
        Stamp = True
    graph()

def apogee():
    global show_apogee
    if show_apogee == True:
        show_apogee = False
    elif show_apogee == False:
        show_apogee = True
    graph()

    
def show_animation():
    set_graph() 
    canvas.draw()
    for i in range(0,len(AnimationX)-1):
        #ax.plot(AnimationX[i], AnimationY[i], 'o', markersize=4, c='darkblue')
        #canvas.draw()
        root.after(100, abc(i))
    #graph()

def abc(i):
    ax.plot(AnimationX[i], AnimationY[i], 'o', markersize=4, c='darkblue')
    canvas.draw()

show_MaxRange = False
def show_max_range():
    global show_MaxRange
    if show_MaxRange == True:
        show_MaxRange = False
    elif show_MaxRange == False:
        show_MaxRange = True
    max_range()

def max_range(*args):
    a = -9.81 
    dt = 0.01 
    t = 0 
    u = initial_velocity
    iHeight = initial_height
    MaxAngle_r = math.asin(1/math.sqrt(2+2*(-1*a)*iHeight/u**2))
    MaxAngle_d = math.degrees(MaxAngle_r)
    hDistance = 0 
    s = 0 
    vDistance = iHeight
    vVelocity = round((u*math.sin(MaxAngle_r)),5)
    hVelocity = round((u*math.cos(MaxAngle_r)),5)

    Max_X = []
    Max_Y = []
    x1 = 0
    x2 = 0
    y1 = iHeight
    y2 = iHeight
    Distance = 0
    temp = 0
    
    while vDistance > 0:
        hDistance = hVelocity*t
        Max_X.append(hDistance)

        s = vVelocity*t + 0.5*a*t**2
        vDistance = iHeight + s
        Max_Y.append(vDistance)

        x2 = x1
        x1 = hDistance
        y2 = y1
        y1 = vDistance
        temp = math.sqrt((x1-x2)**2 + (y1-y2)**2)
        Distance = Distance + temp

        t = t + dt
    t = t-dt
    Distance = Distance - temp
    if show_MaxRange == True:
        ax.plot(Max_X, Max_Y, label=f"[Maximum Range]: θmax ={round(MaxAngle_d,1)}°  T ={round(t,2)}s  Distance ={round(Distance,2)}m")
        ax.legend()
        canvas.draw()
    if show_MaxRange == False:
        graph()


def Bounce():
    set_graph() 
    global Stamp 
    a = -9.81
    t = 0
    dt = 0.01
    c = 0.7
    v = initial_velocity
    thetaD = launch_angle
    thetaR = (2*(math.pi))*(thetaD/360)
    bounce = 0
    Vv = round((v*math.sin(thetaR)),10)
    Hv = round((v*math.cos(thetaR)),10)

    Y = initial_height
    s = 0
    i = True

    x = []
    y = []

    X = 0
    while i==True:
        X = Hv*t

        s = Vv*dt + 0.5*a*dt**2
        Y = Y + s
        Vv = a*dt+Vv

        t = t+dt
    
        if Y <= 0:
            Vv = Vv*c*-1
            Y = 0
            if Vv<=1:
                i = False
            else:
                bounce += 1
        x.append(X)
        y.append(Y)

    t=t-dt
    ax.plot(x,y,markersize=15,label=f"Bounce: Time={round(t,2)}s")
    ax.legend()
    canvas.draw()
            

#* initial velocity's text, slider, entry
iVelocity_label = Label(root, text=f"Initial velocity / ms^-1 : {initial_velocity}", font=12).grid(row=1,column=2, columnspan=2)
iVelocity_slider = Scale(root, from_=0, to=100, resolution=0.01, command=ivSlider, width=15, length=200, font=12, orient=HORIZONTAL)
iVelocity_slider.set(0) 
iVelocity_slider.grid(row=2, column=2, columnspan=2) 
iVelocity_entry = tk.Entry(root, width=7, textvariable=velocity, font=12).grid(row=2,column=4, padx=5)

#* angle's text, slider, entry
angle_label = Label(root,text=f"Launch angle / ° : {launch_angle}", font=12).grid(row=3,column=2, columnspan=2)
angle_slider = Scale(root, from_=0, to=360, resolution=0.01, command=anSlider, width=15, length=200, font=12, orient=HORIZONTAL)
angle_slider.set(0) 
angle_slider.grid(row=4, column=2, columnspan=2)
angle_entry = tk.Entry(root, width=7, textvariable=theta, font=12).grid(row=4, column=4, padx=5)

#* initial height's text, slider, entry
iHeight_label = Label(root,text=f"Initial height / m : {initial_height}", font=12).grid(row=5,column=2, columnspan=2)
iHeight_slider = Scale(root, from_=0, to=50, resolution=0.1, command=ihSlider, width=15, length=200, font=12, orient=HORIZONTAL)
iHeight_slider.set(0) 
iHeight_slider.grid(row=6, column=2, columnspan=2) 
iHeight_entry = tk.Entry(root, width=7, textvariable=height, font=12).grid(row=6, column=4, padx=5)

#* Buttons
Reset_button = Button(root, text='  Reset  ', command=reset_values, font=12).grid(row=8, column=2, columnspan=2)
Plot_button = Button(root, text="     -- Plot graph --     ", command=graph, font=12).grid(row=12, column=2, columnspan=4)
Enter_button = Button(root, text='  Enter  ', command=entry_values, font=12).grid(row=8, column=4, columnspan=2)
TimeStamp_button = Button(root, text="Show time stamp", command=time_stamp, font=12).grid(row=9,column=2, columnspan=2)
Clear_button = Button(root, text="  -- Clear graph --  ", command=set_graph, font=12).grid(row=9,column=4, columnspan=2)
Apogee_button = Button(root, text="  Show apogee  ", command=apogee, font=12).grid(row=10,column=2, columnspan=2)
Animation_button = Button(root, text="   #Animation   ", command=show_animation, font=12).grid(row=11,column=2, columnspan=2)
MaxRange_button = Button(root, text="  MaxRange  ", command=lambda:show_max_range(), font=12).grid(row=10, column=4, columnspan=2)
Bounce_button = Button(root, text="  Bounce  ", command=Bounce, font=12).grid(row=11, column=4, columnspan=2)
#* call the procedure when 'Enter' key from keyboard is pressed
root.bind('<Return>',Enter)

mainloop()
